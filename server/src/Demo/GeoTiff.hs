module Demo.GeoTiff where
  
import Relude
-- import qualified Data.ByteString as BS
-- import Data.Binary.Get

-- type SRational = (Int32, Int32)
-- data IFDEntry = IFDEntry 
--   { tag :: Word16 
--   , dataType :: Word16 
--   , dataCount :: Word32
--   , dataOffset :: Word32
--   } deriving (Show)

-- data GeoTIFF = GeoTIFF
--   { header :: Header
--   , imageData :: ImageData
--   }

-- data Header = Header
--   { headerEndianness :: Word16
--   , headerSignature :: Word16
--   , headerOffset :: Word32
--   -- , headerIFD :: IFD
--   }

-- data ImageData = ImageData
--   { imageDataNumStripsOrTiles :: Int
--   , imageDataStripsOrTiles :: [StripOrTile]
--   }

-- newtype StripOrTile = StripOrTile
--   { stripOrTileScanlines :: [Scanline]
--   }

-- newtype Scanline = Scanline
--   { scanlinePixels :: [Pixel]
--   }

-- data Pixel = Pixel
--   { pixelRed :: Word8
--   , pixelGreen :: Word8
--   , pixelBlue :: Word8
--   }

-- data FieldType = TypeByte
--                | TypeASCII
--                | TypeShort
--                | TypeLong
--                | TypeRational
--                | TypeSByte
--                | TypeUndefined
--                | TypeSShort
--                | TypeSLong
--                | TypeSRational
--                | TypeFloat
--                | TypeDouble


-- decodeGeoTIFF :: LByteString -> Either (LByteString, ByteOffset, String) (LByteString, ByteOffset, GeoTIFF)
-- decodeGeoTIFF = runGetOrFail getGeoTIFF

-- getGeoTIFF :: Get GeoTIFF
-- getGeoTIFF = do
--   -- parse the header and extract relevant information
--   header <- getHeader
--   let (width, height) = getDimensions header
--   -- parse the image data
--   imageData <- getImageData width height
--   return $ GeoTIFF header imageData

-- -- getIFD :: Get IFD
-- -- getIFD = do
-- --   -- parse the IFD (Image File Directory) from the GeoTIFF image
-- --   --
-- --   -- the IFD consists of:
-- --   --   - a 2-byte count of the number of entries in the IFD
-- --   --   - a series of 12-byte IFD entries
-- --   --   - a 4-byte offset to the next IFD (or 0 if there is no next IFD)
-- --   --
-- --   -- each IFD entry consists of:
-- --   --   - a 2-byte tag identifying the type of metadata
-- --   --   - a 2-byte field type specifying the data type of the metadata value
-- --   --   - a 4-byte count of the number of values of the field type
-- --   --   - a 4-byte value or offset to the value
-- --   --
-- --   -- you can use the 'getIFDEntries' and 'getIFDEntry' functions (see below) to parse the IFD entries
-- --   --
-- --   -- then you should return the IFD as a list of '(Tag, Value)' pairs
-- --   numEntries <- getWord16le
-- --   entries <- getIFDEntries numEntries
-- --   nextIFDOffset <- getWord32le
-- --   if nextIFDOffset /= 0
-- --     then do
-- --       -- seek to the start of the next IFD
-- --       skip (fromIntegral nextIFDOffset - 12 - numEntries * 12)
-- --       -- parse the next IFD
-- --       nextIFD <- getIFD
-- --       -- append the next IFD to the current IFD
-- --       return $ entries ++ nextIFD
-- --     else return entries

-- getIFDEntries :: Word16 -> Get IFD
-- getIFDEntries numEntries = do
--   -- parse a list of IFD entries from the GeoTIFF image
--   --
--   -- each IFD entry is a 12-byte field consisting of:
--   --   - a 2-byte tag identifying the type of metadata
--   --   - a 2-byte field type specifying the data type of the metadata value
--   --   - a 4-byte count of the number of values of the field type
--   --   - a 4-byte value or offset to the value
--   --
--   -- you can use the 'getIFDEntry' function (see below) to parse each IFD entry
--   --
--   -- then you should return the IFD entries as a list of '(Tag, Value)' pairs
--   replicateM (fromIntegral numEntries) getIFDEntry

-- getIFDEntry :: Get IFDEntry
-- getIFDEntry = do
--   -- parse an IFD entry from the GeoTIFF image
--   --
--   -- an IFD entry is a 12-byte field consisting of:
--   --   - a 2-byte tag identifying the type of metadata
--   --   - a 2-byte field type specifying the data type of the metadata value
--   --   - a 4-byte count of the number of values of the field type
--   --   - a 4-byte value or offset to the value
--   --
--   -- you should use the 'getTag' and 'getFieldType' functions (see below) to parse the tag and field type
--   --
--   -- then you should use the 'getValue' function (see below) to parse the value or offset to the value
--   --
--   -- finally, you should return the IFD entry as a '(Tag, Value)' pair
--   tag <- getTag
--   fieldType <- getFieldType
--   count <- getWord32le
--   value <- getValue fieldType count
--   return (tag, value)

-- getTag :: Get Tag
-- getTag = do
--   -- parse the tag from the IFD entry
--   --
--   -- the tag is a 2-byte field that identifies the type of metadata
--   -- you should use the 'getWord16le' function to parse the tag
--   getWord16le

-- getFieldType :: Get FieldType
-- getFieldType = do
--   -- parse the field type from the IFD entry
--   --
--   -- the field type is a 2-byte field that specifies the data type of the metadata value
--   -- you should use the 'getWord16le' function to parse the field type
--   -- then you should return the field type as a 'FieldType' value
--   t <- getWord16le
--   case t of
--     1 -> return TypeByte
--     2 -> return TypeASCII
--     3 -> return TypeShort
--     4 -> return TypeLong
--     5 -> return TypeRational
--     6 -> return TypeSByte
--     7 -> return TypeUndefined
--     8 -> return TypeSShort
--     9 -> return TypeSLong
--     10 -> return TypeSRational
--     11 -> return TypeFloat
--     12 -> return TypeDouble
--     _ -> fail $ "Invalid field type: " ++ show t

-- getValue :: FieldType -> Word32 -> Get Value
-- getValue fieldType count = do
--   -- parse the value or offset to the value from the IFD entry
--   --
--   -- the value is a 4-byte field that contains the actual metadata value, or an offset to the value
--   --
--   -- you should use the 'getValueAtOffset' function (see below) to parse the value if it is stored at an offset
--   --
--   -- then you should return the value as a 'Value' value
--   case fieldType of
--     TypeByte -> ValueByteString <$> getByteString (fromIntegral count)
--     TypeASCII -> ValueString <$> getASCIIString count
--     TypeShort -> ValueWord16 <$> getWord16le
--     TypeLong -> ValueWord32 <$> getWord32le
--     TypeRational -> ValueRational <$> getRational
--     TypeSByte -> ValueInt8 <$> getInt8
--     TypeUndefined -> ValueByteString <$> getByteString (fromIntegral count)
--     TypeSShort -> ValueInt16 <$> getInt16le
--     TypeSLong -> ValueInt32 <$> getInt32le
--     TypeSRational -> ValueSRational <$> getSRational
--     TypeFloat -> ValueFloat <$> getFloatle
--     TypeDouble -> ValueDouble <$> getDoublele

-- getValueAtOffset :: FieldType -> Word32 -> Get Value
-- getValueAtOffset fieldType count = do
--   -- parse the value stored at the given offset
--   --
--   -- the value is stored at the current position in the input stream plus the given offset
--   --
--   -- you should use the 'seek' function to move to the correct position in the input stream
--   -- then you should use the 'getValue' function (see above) to parse the value
--   offset <- getWord32le
--   save <- bytesRead
--   seek (fromIntegral offset)
--   value <- getValue fieldType count
--   seek save
--   return value

-- getASCIIString :: Word32 -> Get String
-- getASCIIString count = do
--   -- parse an ASCII string from the input stream
--   --
--   -- the string is 'count' bytes long and consists of ASCII characters
--   -- you should use the 'getWord8' and 'chr' functions to parse the string
--   -- then you should return the string as a Haskell 'String' value
--   bs <- getByteString (fromIntegral count)
--   return $ map (chr . fromIntegral) $ BS.unpack bs

-- getRational :: Get Rational
-- getRational = do
--   -- parse a rational number from the input stream
--   --
--   -- a rational number is a pair of two unsigned integers representing the numerator and denominator of the fraction
--   -- you should use the 'getWord32le' function to parse the numerator and denominator
--   -- then you should return the rational number as a Haskell '(Integer, Integer)' pair
--   num <- getWord32le
--   denom <- getWord32le
--   return (fromIntegral num, fromIntegral denom)

-- getSRational :: Get SRational
-- getSRational = do
--   -- parse a signed rational number from the input stream
--   --
--   -- a signed rational number is a pair of two signed integers representing the numerator and denominator of the fraction
--   -- you should use the 'getInt32le' function to parse the numerator and denominator
--   -- then you should return the signed rational number as a Haskell '(Int32, Int32)' pair
--   num <- getInt32le
--   denom <- getInt32le
--   return (num, denom)


-- getHeader :: Get Header
-- getHeader = do
--   -- parse the header according to the GeoTIFF format specification
--   --
--   -- the GeoTIFF header consists of:
--   --   - a 2-byte endianness indicator
--   --   - a 2-byte TIFF signature
--   --   - a 4-byte offset to the first IFD (Image File Directory)
--   --
--   -- you can use the following functions to parse these fields:
--   endianness <- getWord16le
--   signature <- getWord16le
--   offset <- getWord32le
--   --
--   -- you should check that the endianness is correct (it should be 0x4949 for little-endian)
--   -- and that the TIFF signature is correct (it should be 0x002A)
--   --
--   -- once you have parsed these fields, you can use the 'offset' to seek to the start of the IFD
--   -- and parse it using the 'getIFD' function (see below)
--   if endianness /= 0x4949 || signature /= 0x002A
--     then fail "Invalid GeoTIFF header"
--     else do
--       -- seek to the start of the IFD
--       skip (fromIntegral offset - 8)
--       -- parse the IFD
--       ifd <- getIFD
--       -- return the header
--       return $ Header endianness signature offset ifd

-- lookupTag :: Tag -> IFD -> Maybe Value
-- lookupTag tag ifd = snd <$> find ((== tag) . fst) ifd


-- getDimensions :: Header -> (Int, Int)
-- getDimensions header = do
--   -- extract the width and height from the header
--   --
--   -- the width and height are stored in the IFD (Image File Directory) of the header
--   -- you can use the 'lookupTag' function (see below) to extract them from the IFD
--   --
--   -- the tags for the width and height are 256 and 257, respectively
--   --
--   -- once you have extracted the width and height, you should return them as a tuple
--   let ifd = headerIFD header
--   width <- lookupTag 256 ifd
--   height <- lookupTag 257 ifd
--   return (width, height)

-- getImageData :: Int -> Int -> Get ImageData
-- getImageData width height = do
--   -- parse the image data according to the GeoTIFF format specification
--   --
--   -- the image data consists of a series of strips or tiles, depending on the organization of the data
--   -- in the IFD (Image File Directory)
--   --
--   -- you can use the 'getStripOrTileOffsets' and 'getStripOrTileByteCounts' functions (see below)
--   -- to get the offsets and byte counts for the strips or tiles
--   --
--   -- then you can use the 'getStrip' or 'getTile' function to parse the data for each strip or tile
--   --
--   -- finally, you should return the image data as a 'ImageData' value
--   stripOrTileOffsets <- getStripOrTileOffsets
--   stripOrTileByteCounts <- getStripOrTileByteCounts
--   let numStripsOrTiles = length stripOrTileOffsets
--   stripsOrTiles <- mapM (getStripOrTile width) (zip stripOrTileOffsets stripOrTileByteCounts)
--   return $ ImageData numStripsOrTiles stripsOrTiles

-- getStripOrTileOffsets :: Get [Int]
-- getStripOrTileOffsets = do
--   -- parse the StripOffsets or TileOffsets tag from the IFD
--   --
--   -- the StripOffsets or TileOffsets tag specifies the offsets to the start of each strip or tile
--   -- in the image data
--   --
--   -- the tag is an array of 4-byte integers
--   --
--   -- you can use the 'lookupTag' function (see below) to get the value of the tag from the IFD
--   --
--   -- then you can use the 'getList' function (see below) to parse the array of integers
--   ifd <- getIFD
--   let tag = if isTiled ifd then TileOffsets else StripOffsets
--   offsets <- lookupTag tag ifd
--   getList getWord32le offsets

-- getStripOrTileByteCounts :: Get [Int]
-- getStripOrTileByteCounts = do
--   -- parse the StripByteCounts or TileByteCounts tag from the IFD
--   --
--   -- the StripByteCounts or TileByteCounts tag specifies the number of bytes in each strip or tile
--   -- in the image data
--   --
--   -- the tag is an array of 4-byte integers
--   --
--   -- you can use the 'lookupTag' function (see below) to get the value of the tag from the IFD
--   --
--   -- then you can use the 'getList' function (see below) to parse the array of integers
--   ifd <- getIFD
--   let tag = if isTiled ifd then TileByteCounts else StripByteCounts
--   byteCounts <- lookupTag tag ifd
--   getList getWord32le byteCounts

-- getStripOrTile :: Int -> (Int, Int) -> Get StripOrTile
-- getStripOrTile width (offset, byteCount) = do
--   -- parse a strip or tile from the image data
--   --
--   -- the strip or tile is a series of scanlines, each of which is 'width' pixels wide
--   --
--   -- you should use the 'getScanlines' function (see below) to parse the scanlines
--   --
--   -- then you should return the strip or tile as a 'StripOrTile' value
--   skip (fromIntegral offset)
--   scanlines <- getScanlines width byteCount
--   return $ StripOrTile scanlines

-- getScanlines :: Int -> Int -> Get [Scanline]
-- getScanlines width byteCount = do
--   -- parse the scanlines from the image data
--   --
--   -- each scanline consists of 'width' pixels
--   -- you should use the 'getPixels' function (see below) to parse the pixels in each scanline
--   --
--   -- the total number of bytes in the scanlines should be 'byteCount'
--   -- you should use the 'remaining' function to check that you have parsed the correct number of bytes
--   scanlines <- getList (getScanline width) (byteCount `div` width)
--   let remainingBytes = remaining
--   if remainingBytes /= 0
--     then fail $ "Error parsing scanlines: " ++ show remainingBytes ++ " bytes remaining"
--     else return scanlines

-- getScanline :: Int -> Get Scanline
-- getScanline width = do
--   -- parse a single scanline from the image data
--   --
--   -- a scanline consists of 'width' pixels
--   -- you should use the 'getPixels' function (see below) to parse the pixels
--   --
--   -- then you should return the scanline as a 'Scanline' value
--   pixels <- getPixels width
--   return $ Scanline pixels

-- getPixels :: Int -> Get [Pixel]
-- getPixels width = do
--   -- parse the pixels from the image data
--   --
--   -- each pixel consists of 3 bytes (red, green, blue)
--   -- you should use the 'getWord8' function to parse each byte
--   --
--   -- then you should return the pixels as a list of 'Pixel' values
--   pixels <- replicateM width $ do
--     r <- getWord8
--     g <- getWord8
--     b <- getWord8
--     return $ Pixel r g b
--   return pixels

